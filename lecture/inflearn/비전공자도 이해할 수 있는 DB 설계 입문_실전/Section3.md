# DB 설계의 핵심 원칙 및 전체 과정

## **DB 설계의 핵심은 '중복 없애기'이다.**

- **정의**:  
  데이터베이스 설계의 가장 중요한 원칙은 중복된 데이터를 제거하여 데이터 무결성을 유지하고, 저장소와 성능을 최적화하는 것입니다. 이를 위해 정규화를 비롯한 다양한 설계 기법을 사용합니다.

- **중복이 문제를 일으키는 이유**:

  1. **데이터 무결성 훼손**:
     - 동일한 데이터가 여러 곳에 저장되면, 업데이트할 때 모든 복사본을 수정해야 하므로 실수로 일부만 수정되는 경우 데이터가 불일치 상태에 빠질 수 있습니다.
  2. **스토리지 낭비**:
     - 중복된 데이터를 저장하면 저장 공간이 불필요하게 낭비됩니다.
  3. **성능 저하**:
     - 중복된 데이터를 처리하는 데 더 많은 시간이 소요되어 쿼리 성능이 저하됩니다.

- **해결 방법**:  
  정규화(Normalization)를 통해 중복을 최소화하고, 테이블을 효율적으로 설계합니다.

---

### **예시 케이스**

#### **중복된 설계의 문제**

- **비효율적인 테이블 설계**:
  Orders 테이블:
  OrderID | CustomerName | CustomerEmail | ProductName | Quantity
  --------|--------------|---------------------|---------------|---------
  101 | Alice | alice@email.com | Laptop | 1
  102 | Alice | alice@email.com | Mouse | 2
  103 | Bob | bob@email.com | Keyboard | 1

#### **중복 제거를 위한 개선된 설계**

- **정규화를 적용한 설계**

1. **Customers 테이블**  
   고객 정보를 별도로 관리하여 중복을 제거합니다.

   Customers 테이블:
   CustomerID | CustomerName | CustomerEmail
   -----------|--------------|---------------------
   1 | Alice | alice@email.com
   2 | Bob | bob@email.com

2. **Orders 테이블**  
   주문 정보는 고객 ID를 참조하여 고객 정보와 연결합니다.

   | OrderID | CustomerID | ProductName | Quantity |
   | ------- | ---------- | ----------- | -------- |
   | 101     | 1          | Laptop      | 1        |
   | 102     | 1          | Mouse       | 2        |
   | 103     | 2          | Keyboard    | 1        |

## **정규화(Normalization)란?**

- **정의**:  
  정규화(Normalization)는 데이터베이스 설계 과정에서 중복 데이터를 최소화하고, 데이터 무결성을 보장하기 위해 데이터를 체계적으로 분리하는 작업입니다. 이를 통해 효율적인 데이터 저장 및 관리가 가능하며, 데이터의 일관성과 정확성을 유지할 수 있습니다.

---

### **정규화의 목적**

1. **중복 제거**: 데이터의 반복 저장을 방지하여 저장 공간을 절약합니다.
2. **데이터 무결성 보장**: 중복된 데이터로 인한 불일치나 오류를 최소화합니다.
3. **유지보수 용이**: 데이터 수정 시, 하나의 테이블만 변경하면 되므로 작업이 간편해집니다.
4. **쿼리 성능 향상**: 정규화된 데이터는 관계형 데이터베이스의 특성을 활용해 효율적으로 처리됩니다.

---

### **정규화의 단계**

1. **제1정규형(1NF)**

   - 테이블의 각 열이 원자값(Atomic Value)만 가지도록 분리합니다.
   - 예: `전화번호` 열에 여러 개의 전화번호를 저장하지 않고, 각각의 전화번호를 별도의 행으로 분리합니다.

   **예시**:
   | CustomerID | PhoneNumbers |
   |------------|--------------------|
   | 1 | 123-456-7890, 987-654-3210 |

   **1NF 변환 후**:
   | CustomerID | PhoneNumber |
   |------------|--------------------|
   | 1 | 123-456-7890 |
   | 1 | 987-654-3210 |

2. **제2정규형(2NF)**

   - 1NF를 만족하며, 기본키의 **일부가 아닌 전체**에 종속된 속성만을 포함하도록 분리합니다.
   - 예: 주문 테이블에서 `ProductName`이 `OrderID`와만 관련된 경우, 이를 별도로 분리.

   **예시**:
   | OrderID | ProductName | Quantity | CustomerName |
   |---------|---------------|----------|--------------|

   **2NF 변환 후**:

   - Orders 테이블:
     | OrderID | ProductID | Quantity |
     |---------|-----------|----------|
     | 101 | 1 | 1 |
     | 102 | 2 | 2 |
   - Products 테이블:
     | ProductID | ProductName |
     |-----------|---------------|
     | 1 | Laptop |
     | 2 | Mouse |

3. **제3정규형(3NF)**

   - 2NF를 만족하며, 비키 속성이 다른 비키 속성에 종속되지 않도록 분리합니다.
   - 예: `CustomerName`이 `CustomerID`에만 종속될 경우, 이를 분리.

   **예시**:

   - Orders 테이블:
     | OrderID | CustomerID | ProductID | Quantity |
     |---------|------------|-----------|----------|
   - Customers 테이블:
     | CustomerID | CustomerName |
     |------------|--------------|

---

### **정규화의 장점**

- 중복 데이터를 줄여 저장 공간 절약.
- 데이터 변경 및 삭제 시, 일관성과 무결성 유지.
- 데이터베이스 성능 최적화.

---

### **정규화의 단점**

- 지나치게 세분화된 테이블은 쿼리가 복잡해질 수 있음.
- 조인 연산이 많아질 경우, 성능이 저하될 가능성 있음.

---

#### 면접용 답변

> RDBMS에서 데이터 모델링을 할 때는 정규화를 통해 데이터 중복을 최소화할 수 있게 설계해야 합니다. 그래야 삽입 이상, 수정 이상, 삭제 이상과 같은 이상현상을 방지할 수 있으며 데이터 무결성을 지킬 수 있습니다.

### **결론**

정규화는 데이터베이스 설계에서 필수적인 과정으로, 중복 제거와 데이터 무결성을 보장합니다. 그러나 성능 요구에 따라 적절한 수준에서 정규화를 적용해야 하며, 경우에 따라 비정규화를 고려할 수도 있습니다.

## **DB 설계 전체 과정**

### **1. 저장해야 하는 데이터 파악하기**

- **정의**:  
  데이터베이스 설계의 첫 번째 단계는 저장해야 할 데이터를 정의하고 그 구조를 이해하는 것입니다. 이는 시스템에서 요구하는 모든 데이터를 분석하여 목록화하는 작업입니다.

- **방법**:

  1. 요구사항 분석:
     - 시스템에서 어떤 데이터를 관리해야 하는지 도출합니다.
     - 예: 사용자 정보, 주문 내역, 상품 데이터 등.
  2. 데이터 속성 파악:
     - 각 데이터가 어떤 속성을 가지는지 정의합니다.
     - 예: 사용자 정보는 이름, 이메일, 전화번호 등의 속성을 가질 수 있습니다.
  3. 데이터 관계 정의:
     - 데이터 간의 관계(1:1, 1:N, N:M)를 파악합니다.
     - 예: 한 사용자가 여러 주문을 할 수 있는 관계.

- **예시**:
  - 사용자 정보:
    - 속성: `UserID`, `Name`, `Email`, `PhoneNumber`
  - 주문 정보:
    - 속성: `OrderID`, `UserID`, `OrderDate`, `TotalAmount`

---

### **2. 그룹핑해서 분류하기**

- **정의**:  
  저장할 데이터를 그룹핑하여 테이블로 분류하는 단계입니다. 이는 유사한 속성을 가진 데이터를 하나의 테이블로 묶고, 테이블 간의 관계를 정의하는 작업입니다.

- **방법**:

  1. **속성 기반 분류**:
     - 속성이 비슷한 데이터끼리 묶어서 테이블로 만듭니다.
     - 예: 사용자 정보는 `users` 테이블, 주문 정보는 `orders` 테이블로 분리.
  2. **관계 정의**:
     - 테이블 간의 관계를 식별하여 외래키(Foreign Key)로 연결합니다.
     - 예: `orders` 테이블의 `UserID`는 `users` 테이블의 `UserID`를 참조.
  3. **정규화 적용**:
     - 데이터를 중복 없이 관리하기 위해 정규화를 적용하여 테이블 구조를 세분화합니다.

- **예시**:

  - 분류된 테이블:

    - `users` 테이블:
      | UserID | Name | Email | PhoneNumber |
      |--------|--------|-----------------|----------------|
      | 1 | Alice | alice@email.com | 123-456-7890 |
      | 2 | Bob | bob@email.com | 987-654-3210 |

    - `orders` 테이블:
      | OrderID | UserID | OrderDate | TotalAmount |
      |---------|--------|------------|-------------|
      | 101 | 1 | 2024-01-01 | 150.00 |
      | 102 | 2 | 2024-01-02 | 200.00 |

- **결과**:
  데이터를 테이블로 분리하여 중복을 최소화하고, 테이블 간의 관계를 명확히 정의합니다.
