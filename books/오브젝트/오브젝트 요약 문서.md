## 1. 객체, 설계

### 애플리케이션의 핵심 클래스
![그림 1.1 애플리케이션의 핵심 클래스](/books/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/image/Chapter1_1_%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3.drawio.png)

- 객체를 자율적으로 설계해야한다.
- 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.
- 캡슐화의 핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다.
- 객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야 하고 이렇게 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 객체지향 프로그래밍이라고 부른다.
- 각 객체는 자신을 스스로 책임진다.
- 결과적으로 불필요한 세부사항을 객체 내부로 캡슐화하는 것은 객체의 자율성을 높이고 응집도 높은 객체들의 공동체를 창조할 수 있게 한다.
- 좋은 설계한 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다.

<hr>

## 2. 객체지향 프로그래밍
- 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.
- 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현하라.
- 경계의 명확성이 객체의 자율성을 보장한다.
- 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워 진다.
- 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다.
- 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다는 것을 기억하라.
- 인터페이스를 재사용할 목적이 아니라 구현을 재사용할 목적으로 상속을 사용하면 ㅂ녀경에 취약한 코드를 낳게 될 확률이 높다.
- 항상 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택하라.
- 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다.
- 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다속
- 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다.

## 3. 역할, 책임, 협력
- 객체는 자신의 상태를 스스로 결정하고 관리하는 자율적인 존재이기 때문에 객체가 수행하는 행동에 필요한 상태도 함께 가지고 있어야 한다.
- 객체지향 설계에서 가장 중요한 것은 책임이다. 객체에게 얼마나 적절한 책임을 할당하느냐가 설계의 전체적인 품질을 결정한다.
- 자율적인 객체를 만든느 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것이다.
- 객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이뤄진다. 그리고 이런 메시지가 메시지를 수신할 객체의 책임을 결정한다.
- 메시지가 객체를 결정하고 행동이 상태를 결정한다.
- 객체가 충분히 추상적이면서 미니멀리즘을 따르는 인터페이스를 가지게 하고 싶다면 메시지가 객체를 선택하게 하라.
- 객체를 객체답게 만드는 것은 객체의 상태가 아니라 객체가 다른 객체에게 제공하는 행동이다.
- 상태는 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료일뿐이다.
- 추상 클래스는 책임의 일부를 구현해 놓은 것이고 인터페이스는 일체의 구현 없이 책임의 집합만을 나열해 놓은것이다.

<hr>

## 4. 설계 품질과 트레이드오프
- 객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것이다. 
- 객체는 자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개해서는 안된다. 객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다.
- 사실 캡슐화는 변경될 수 있는 어떤 것이라도 감추는 것을 의미한다.
- 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다.

<hr>

## 5. 책임 할당하기
- 객체에게 중요한 것은 데이터가 아니라 외부에 제공하는 행동이다.
- 협력에 적합한 책임을 수확하기 위해서는 객체를 결정한 후에 메시지를 선택하는 것이 아니라 메시지를 결정한 후에 객체를 선택해야 한다.
> "이 클래스가 필요하다는 점은 알겠는데 이 클래스는 무엇을 해야 하지?"라고 질문하지 않고 "메시지를 전송해야 하는데 누구에게 전송해야 하지?"라고 질문하는 것. 설계의 핵심 질문을 이렇게 바꾸는 것이 메시지 기반 설계로 향하는 첫걸음이다.
- 책임 주도 설계의 핵심은 책임을 결정한 후에 책임을 수행할 객체를 결정하는 것이다.
### 5.1 설계 방법
#### 5.1.1 도메인 개념에서 출발하기
- 어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념이다.
- 도메인 개념을 정리하는 데 너무 많은 시간을 들이지 말고 빠르게 설계와 구현을 진행하다.
#### 5.1.2 정보 전문가에게 책임을 할당하라
- 객체에게 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다.
#### 5.1.3 높은 응집도와 낮은 결합도
#### 5.1.4 창조자에게 객체 생성 책임을 할당하라
>CREATOR 패턴
>- 객체 A를 생성해야 할 때 어떤 객체에게 객체 생성 책임을 할당해야 할 지 고민될때 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라
>- B가 A 객체를 포함하건가 참조한다.
>- B가 A 객체를 기록한다.
>- B가 A 객체를 긴밀하게 사용한다.
>- B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다(이 경우 B는 A에 대한 정보 전문가다)

### 5.2 코드를 통해 변경의 이유를 파악할 수 있는 방법
- 인스턴스 변수가 초기화되는 시점에 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다. 반면 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화하고 일부는 초기화되지 않은 ㅅ아태로 남겨진다.
- 클래스의 속성이 서로 다른 시점에 초기화되거나 일부만 초기화된다는 것은 응집도가 낮다는 증거다. 따라서 함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.
- 메서드들이 인스턴스 변수를 사용하는 방식에서 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다. 반면 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다.

### 5.3 다형성을 통해 분리하기
- 역할을 대체할 클래스들 사이에서 구현을 공유해야 할 필요가 있다면 추상 클래스를 사용하면 된다. 구현을 공유할 필요 없이 역할을 대체하는 객체들의 책임만 정의하고 싶다면 인터페이스를 사용하면 된다.
- 하나의 클래스가 여러 타입의 행동을 구현하고 있는 것처럼 보인다면 클래스를 분해하고 책임을 분산시켜라.

<hr>

## 6. 메시지와 인터페이스
- 객체의 퍼블릭 인터페이스가 객체의 품질을 결정하기 때문에 결국 메시지가 객체의 품질을 결정한다고 할 수 있다.
- 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜라.
### 6.1 메서드명 작성 방법
- 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는다.
- '어떻게'가 아니라 '무엇'을 하는지를 드러내는 것이다.
- 오퍼레이션은 클라이언트가 객체에게 무엇을 원하느지를 표현해야 한다. 다시 말해 객체 자신이 아닌 클라이언트의 의도를 표현하는 이름을 가져야 한다.
- 디미터의 법칙을 위반하는지 판단하고 싶으면 다음과 같은 질문을 해보자. 과연 여러 개의 도트를 사용한 코드가 객체의 내부 구조를 노출하고 있는가?
- 명령-쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것이다. 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안 된다.
- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.
- 중요한 것은 협력에 적합한 객체가 아니라 협력에 적합한 메시지다. 책임 주도 설계 방법에 따라 메시지가 객체를 결정하게 하라.
## 실습 코드
[오브젝트 실습 코드 주소](https://github.com/joohyuk2074/TIL_PRACTICE_CODE/tree/master/object)

### 참고
- [오브젝트](http://www.yes24.com/Product/Goods/74219491)